(define (KL P Q)
  (sum (map (lambda (xp xq)
              (if (= xp 0)
                  0
                  (*
                   xp
                   (log (/ xp
                           xq)))))
            (second P) (second Q))))

;; Helper function
(define (power lst alpha) (map (lambda (x) (expt x alpha)) lst))
(define (topower dist alpha) (list (first dist)
                                   (power (second dist) alpha)))

(define (plural-predication number-of-objects
                            noise
                            knowledge
                            )

  (define utterances (list  
                      'null 
                      'amb 
                      'collective 
                      'distributive 
                      ))
  (define (utterance-prior) (multinomial utterances 
                                         '(
                                           1 
                                           1 
                                           1 
                                           1 
                                           )))

  (define object-prior '((3 4) (1 1)))

  (define (state-prior) 
    (repeat number-of-objects (lambda () (apply multinomial object-prior) ;;the degree
                                )))
  ;; Prior on theta
  (define (dist-theta-prior) (apply multinomial object-prior))
  (define (coll-theta-prior) (sum (state-prior)))


  ;;  collective measurement noise
  (define noise-prior (case noise
                            (('no)
                             (lambda () 1)) ;; no noise                            
                            (('low)
                             (lambda () (multinomial '(.75 1 1.25) 
                                                     '(1 6 1)))) ;; low
                            (('mid) 
                             (lambda () (multinomial '(.75 1 1.25) 
                                                     '(1 3 1)))) ;; middle
                            (('high)
                             (lambda () (multinomial '(.75 1 1.25) 
                                                     '(1 1 1)))) ;; high
                            )) 
  ; 
  (define collective-interpretation 
    (lambda (state coll-theta collective-noise) 
      (if
       (> (* collective-noise (sum state))  coll-theta) ; noise as multiplier
;;        (flip 0.95)
;;        (flip 0.05))))
   #t
   #f)))
  (define distributive-interpretation 
    (lambda (state dist-theta) 
      (if
       (all (map (lambda (d) (> d dist-theta)) state))
;;        (flip 0.95)
;;        (flip 0.05))))
   #t
   #f)))

  (define (meaning utterance state dist-theta coll-theta collective? collective-noise)
    (case utterance
          (('null)
           #t)
          (('amb)
           (if collective?
               (collective-interpretation state coll-theta collective-noise)
               (distributive-interpretation state dist-theta)))
          (('not-amb)
           (if collective?
               (not (collective-interpretation state coll-theta collective-noise))
               (not (distributive-interpretation state dist-theta))))
          (('distributive)
           (distributive-interpretation state dist-theta))
          (('collective)
           (collective-interpretation state coll-theta collective-noise))))

  ;; Pragmatic listener
  (define prag-listener
    (mem
     (lambda (utterance speakerknows)
       (enumeration-query
        (define state (state-prior))
        (define collective? (flip 0.5))
        (define dist-theta (dist-theta-prior))
        (define coll-theta (coll-theta-prior)) ; coll-theta independent

        (list collective? state)
    
        (condition (equal? utterance 
                           (apply multinomial 
                                  (topower (speaker collective? state dist-theta coll-theta speakerknows)
                                           alpha))))
        ))))

  ;; Speaker
  (define speakers-belief
    (mem
       (lambda (state knowledge)
         (define (obs s) (if knowledge s (sum s)))
         (enumeration-query
          (define bstate (state-prior))
          bstate
          (equal? (obs bstate) (obs state))
          ))))
  
  (define speaker 
    (mem
    (lambda (collective? state dist-theta coll-theta knowstate)
    (enumeration-query
     (define utterance (utterance-prior))
     
     (define bstate (speakers-belief state knowstate))

     utterance

     (factor (- (KL bstate (listener utterance collective? dist-theta coll-theta) )))
     ))))

  ;; Literal listener
  (define listener
    (mem
     (lambda (utterance collective? dist-theta coll-theta)
       (enumeration-query
        (define collective-noise (noise-prior))
        (define state (state-prior))
        state
        (condition (meaning utterance state dist-theta coll-theta collective? collective-noise))
        ))))

  (prag-listener 'amb knowledge)
  ;;(listener 'amb true 3 7)

  )

;; speaker rationality
(define alpha 1)

; (multiviz
;  (barplot (plural-predication 2 'no false) "no noise")
;  (barplot (plural-predication 2 'low false) "low noise")
;  (barplot (plural-predication 2 'mid false) "mid noise")
;  (barplot (plural-predication 2 'high false) "high noise")
;  )

;; wrapper

(define model
  (mem
     (lambda (number-of-objects 
          noise 
          knowledge
          )     
       (display (string-append "beginning model with noise=" noise))  
       (define likelihood (plural-predication 
                  number-of-objects 
                  noise 
                  knowledge
                  ))
       (list  noise 
            number-of-objects 
            knowledge
            likelihood))))


(define noises '(high mid low no))
(define numbers-of-objects '(2))
(define knowledges '(false))

(define (unpack m)
  (apply map (append (list (lambda (state-etc probability)
                             (append
                              (list (first m)
                                    (second m)
                                    (third m)
                                    (first state-etc))
                              (second state-etc)
                              (list probability))))
                 (last m))))

(define data
  (apply append
  (apply append
    (apply append       
      (map (lambda (knowledge)
      (map (lambda (noise)
        (map (lambda (number-of-objects)
               (define m (model number-of-objects noise knowledge))
               (unpack m))
         numbers-of-objects)) 
      noises))    
    knowledges))
    )
))

(display data)

(write-csv data "plural-predication-KL.csv")