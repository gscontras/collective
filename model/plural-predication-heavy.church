;; helper function to check list identity
(define (naive-list-equals? as bs)
  (if (not (= (length as) (length bs)))
      false
      (all (map equal? as bs))))

;; helper function to get position of an element x in a haystack lst
(define (position* lst x) 
  (if (null? lst) 
      -Infinity
      (if (naive-list-equals? (first lst) x)
          0
          (+ 1 (position* (rest lst) x)))))

;; helper functiont to compute the maximum support for KL
(define max-support 
  (lambda (dist maximal-support)
    (map 
     (lambda (x)
       (if (> (position* (first dist) x) -1)
           (list-ref (second dist) (position* (first dist) x))
           0))
     (first maximal-support))))

;; helper function to compute KL divergence
(define (KL P Q)
  (sum (map (lambda (xp xq)
              (if (= xp 0)
                  0
                  (*
                   xp
                   (log (/ xp
                           xq)))))
            P Q)))

;; helper function for speaker optimality
(define (power lst alpha) (map (lambda (x) (expt x alpha)) lst))
(define (topower dist alpha) (list (first dist)
                                   (power (second dist) alpha)))

;; helper for erf(x)
(define (t x)
  (/ 1 
     (+ 1 (* 0.3275911 x))
     )
  )
(define (erf x)
  (- 1 (* (+ (* 0.254829592 (t x))
             (* -0.284496736 (expt (t x) 2))
             (* 1.421413741 (expt (t x) 3))
             (* -1.453152027 (expt (t x) 4))
             (* 1.061405429 (expt (t x) 5)))          
          (exp (* -1 (expt x 2))))
     )
  )

;; the full model starts here
(define (plural-predication number-of-objects
                            noise
                            knowledge
                            )

  ;; possible utterance 
  (define utterances (list  
                      'amb
                      'collective 
                      'distributive 
                      ))

  ;; ambiguous utterance is cheaper
  (define (utterance-prior) (multinomial utterances '(2 1 1)))

  ;; object come in two sizes, 3 and 4  , with equal probability
  (define object-prior '((3 4) (1 1)))

  ;; states are n random draws from the obejct prior where n=number-of-objects
  (define (state-prior) 
    (repeat number-of-objects (lambda () (apply multinomial object-prior) 
                                )))

  ;; prior on thresholds
  (define (dist-theta-prior) (apply multinomial object-prior))
  (define (coll-theta-prior) (sum (state-prior)))


  ;; contextual noise in collective interpretation
  (define noise-value (case noise
                            (('no)
                             0.02) ;; no noise                            
                            (('low)
                             1) ;; low
                            (('mid) 
                             2) ;; middle
                            (('high)
                             3) ;; high
                            (('heavy)
                             0.7) ;; heavy
                            (('tall-reg)
                             0.1) ;; (tall; regular)                         
                            (('big-reg)
                             1) ;; (big; regular)
                            (('tall-ran)
                             3) ;; (tall; random)
                            (('big-ran)
                             3) ;; (big; random)
                            ))

  ;; interpretation semantics
  (define collective-interpretation 
    (lambda (state coll-theta collective-noise) 
      ;;       (if
      ;;        (> (* collective-noise (sum state))  coll-theta) 
      ;;        #t
      ;;        #f)
      (flip ;;additive noise
       (- 1 (* (+ 1 (erf (/ (- (- coll-theta (sum state)) 0) 
                            (* collective-noise (sqrt 2))))) 
               0.5)))
      ;;             (flip (+ 0.5 (* 0.5 ;; multiplicative noise
      ;;                             (erf (/ (- (log (/ coll-theta (sum state))) 1)
      ;;                                     (* (sqrt 2) collective-noise))) )))
      ))
  (define distributive-interpretation 
    (lambda (state dist-theta) 
      (if
       (all (map (lambda (d) (> d dist-theta)) state))
       ; (flip 0.99)
       ; (flip 0.01))))
       #t
       #f)))

  ;; utterance semantics
  (define (meaning utterance state dist-theta coll-theta collective? collective-noise)
    (case utterance
          (('amb)
           (if collective?
               (collective-interpretation state coll-theta collective-noise)
               (distributive-interpretation state dist-theta)))
          (('not-amb)
           (if collective?
               (not (collective-interpretation state coll-theta collective-noise))
               (not (distributive-interpretation state dist-theta))))
          (('distributive)
           (distributive-interpretation state dist-theta))
          (('collective)
           (collective-interpretation state coll-theta collective-noise))))

  ;; pragmatic listener L1
  (define prag-listener
    (mem
     (lambda (utterance speakerknows)
       (enumeration-query
        (define state (state-prior))
        (define collective? (flip 0.9)) ; prior on collective interpretation
        (define dist-theta (dist-theta-prior))
        (define coll-theta (coll-theta-prior))

        (list collective? state)
        ; collective?

        (condition (equal? utterance 
                           (apply multinomial 
                                  (topower (speaker collective? state dist-theta coll-theta speakerknows)
                                           10)))) ;; needs to be greater than 3.5
        ))))

  ;; speaker belief function for epistemic manipulation
  (define speakers-belief
    (mem
     (lambda (state knowledge)
       (define (obs s) (if knowledge s (sum s)))
       (enumeration-query
        (define bstate (state-prior))
        bstate
        (equal? (obs bstate) (obs state))
        ))))

  ;; speaker S1
  (define speaker 
    (mem
     (lambda (collective? state dist-theta coll-theta knowstate)
       (enumeration-query
        (define utterance (utterance-prior))
        (define bstate-distribution (speakers-belief state knowstate))
        (define listener-dist (listener utterance collective? dist-theta coll-theta))
        (define speaker-dist 
          (max-support bstate-distribution listener-dist))


        utterance

        (factor (- (KL speaker-dist (second listener-dist))))
        ))))

  ;; literal listener L0
  (define listener
    (mem
     (lambda (utterance collective? dist-theta coll-theta)
       (enumeration-query
        (define collective-noise noise-value)
        (define state (state-prior))
        state
        (condition (meaning utterance state dist-theta coll-theta collective? collective-noise))
        ))))

  ;; model computes probability of collective for ambiguous utterance
  (prag-listener 'amb knowledge) 

  )

; ;; model predictions for 4-object states
; (barplot (plural-predication 4 'no #T) "no noise, full knowledge")
; (barplot (plural-predication 4 'no #F) "no noise, partial knowledge")
; (barplot (plural-predication 4 'low #T) "low noise, full knowledge")
; (barplot (plural-predication 4 'low #F) "low noise, partial knowledge")
; (barplot (plural-predication 4 'mid #T) "mid noise, full knowledge")
; (barplot (plural-predication 4 'mid #F) "mid noise, partial knowledge")
; (barplot (plural-predication 4 'high #T) "high noise, full knowledge")
; (barplot (plural-predication 4 'high #F) "high noise, partial knowledge")



;; speaker rationality
; (define alpha 2)

; (multiviz
;  (barplot (plural-predication 2 'no false) "no noise")
;  (barplot (plural-predication 2 'low false) "low noise")
;  (barplot (plural-predication 2 'mid false) "mid noise")
;  (barplot (plural-predication 2 'high false) "high noise")
;  )

;; wrapper

(define model
  (mem
     (lambda (number-of-objects 
          noise 
          knowledge
          )     
       ; (display (string-append "beginning model with noise=" noise))  
       (define likelihood (plural-predication 
                  number-of-objects 
                  noise 
                  knowledge
                  ))
       (list  noise 
            number-of-objects 
            knowledge
            likelihood))))


(define noises '(heavy))
(define numbers-of-objects '(2))
(define knowledges '(true false))

(define (unpack m)
  (apply map (append (list (lambda (state-etc probability)
                             (append
                              (list (first m)
                                    (second m)
                                    (third m)
                                    (first state-etc))
                              (second state-etc)
                              (list probability))))
                 (last m))))

(define data
  (apply append
  (apply append
    (apply append       
      (map (lambda (knowledge)
      (map (lambda (noise)
        (map (lambda (number-of-objects)
               (define m (model number-of-objects noise knowledge))
               (unpack m))
         numbers-of-objects)) 
      noises))    
    knowledges))
    )
))

(display data)

(write-csv data "plural-predication-heavy.csv")