(define (naive-list-equals? as bs)
  (if (not (= (length as) (length bs)))
      false
      (all (map equal? as bs))))

;; gets position of an element x in a haystack lst
;; where every element in lst is itself a simple list
(define (position* lst x) 
  (if (null? lst) 
      -Infinity
      (if (naive-list-equals? (first lst) x)
          0
          (+ 1 (position* (rest lst) x)))))

(define max-support 
  (lambda (dist maximal-support)
    (map 
     (lambda (x)
       (if (> (position* (first dist) x) -1)
           (list-ref (second dist) (position* (first dist) x))
           0))
     (first maximal-support))))

(define (KL P Q)
  (sum (map (lambda (xp xq)
              (if (= xp 0)
                  0
                  (*
                   xp
                   (log (/ xp
                           xq)))))
            P Q)))

;; Helper function
(define (power lst alpha) (map (lambda (x) (expt x alpha)) lst))
(define (topower dist alpha) (list (first dist)
                                   (power (second dist) alpha)))

(define (plural-predication number-of-objects
                            noise
                            knowledge
                            )

  (define utterances (list  
                      ;'null 
                      'amb 
                       'collective 
                       'distributive 
                      ))
  (define (utterance-prior) (multinomial utterances 
                                         '(
;;                                            1 
                                           2 
                                           1 
                                           0.5 
                                           )))

  (define object-prior '((1 2 3 4) (1 1 1 1)))

  (define (state-prior) 
    (repeat number-of-objects (lambda () (apply multinomial object-prior) ;;the degree
                                )))
  ;; Prior on theta
  (define (dist-theta-prior) (apply multinomial object-prior))
  (define (coll-theta-prior) (sum (state-prior)))


  ;;  collective measurement noise
  (define noise-prior (case noise
                            (('no)
                             (lambda () 1)) ;; no noise                            
                            ; (('mid)
                            ;  (lambda () (multinomial '(.75 1 1.25) 
                            ;                          '(1 1 1)))) ;; low
                            (('mid) 
                             (lambda () (multinomial '(.65 1 1.35) 
                                                     '(1.1 1 1.1)))) ;; middle
                            ; (('high)
                            ;  (lambda () (multinomial '(.5 1 1.5) 
                            ;                          '(1 1 1)))) ;; high
                            ))
  ; 
  (define collective-interpretation 
    (lambda (state coll-theta collective-noise) 
      (if
       (> (* collective-noise (sum state))  coll-theta) ; noise as multiplier
              ; (flip 0.99)
              ; (flip 0.01))))
       #t
       #f)))
  (define distributive-interpretation 
    (lambda (state dist-theta) 
      (if
       (all (map (lambda (d) (> d dist-theta)) state))
                     ; (flip 0.99)
                     ; (flip 0.01))))
       #t
       #f)))

  (define (meaning utterance state dist-theta coll-theta collective? collective-noise)
    (case utterance
          (('null)
           #t)
          (('amb)
           (if collective?
               (collective-interpretation state coll-theta collective-noise)
               (distributive-interpretation state dist-theta)))
          (('not-amb)
           (if collective?
               (not (collective-interpretation state coll-theta collective-noise))
               (not (distributive-interpretation state dist-theta))))
          (('distributive)
           (distributive-interpretation state dist-theta))
          (('collective)
           (collective-interpretation state coll-theta collective-noise))))

  ;; Pragmatic listener
  (define prag-listener
    (mem
     (lambda (utterance speakerknows)
       (enumeration-query
        (define state (state-prior))
        (define collective? (flip 0.8))
        (define dist-theta (dist-theta-prior))
        (define coll-theta (coll-theta-prior)) ; coll-theta independent

        (list collective? state)
        ; collective?
        ;;         state
        ;;         (list dist-theta coll-theta)


        ;;                         (apply multinomial 
        ;;                                (topower (speaker collective? state dist-theta coll-theta speakerknows)
        ;;                                         alpha))

        (condition (equal? utterance 
                           (apply multinomial 
                                  (topower (speaker collective? state dist-theta coll-theta speakerknows)
                                           alpha))))
        ))))

  ;; Speaker
  (define speakers-belief
    (mem
     (lambda (state knowledge)
       (define (obs s) (if knowledge s (sum s)))
       (enumeration-query
        (define bstate (state-prior))
        bstate
        (equal? (obs bstate) (obs state))
        ))))

  (define speaker 
    (mem
     (lambda (collective? state dist-theta coll-theta knowstate)
       (enumeration-query
        (define utterance (utterance-prior))
        ;;         (define listeners-world (apply multinomial 
        ;;                                        (listener utterance collective? dist-theta coll-theta
        ;;                                                  ))) 

        (define bstate-distribution (speakers-belief state knowstate))
        (define listener-dist (listener utterance collective? dist-theta coll-theta))
        (define speaker-dist 
          (max-support bstate-distribution listener-dist))


        utterance
        ;;         (list speaker-dist listener-dist)
        ;;           (list  bstate-distribution speaker-dist)
        ;;              (listener utterance collective? dist-theta coll-theta)
        ;;              (KL bstate-distribution (listener utterance collective? dist-theta coll-theta) )

        ;;              (equal? listeners-world state )
        ;;         (factor (- (KL bstate-distribution (listener utterance collective? dist-theta coll-theta) )))

        (factor (- (KL speaker-dist (second listener-dist)
                       )))

        ))))

  ;; Literal listener
  (define listener
    (mem
     (lambda (utterance collective? dist-theta coll-theta)
       (enumeration-query
        (define collective-noise (noise-prior))
        (define state (state-prior))
        state
        (condition (meaning utterance state dist-theta coll-theta collective? collective-noise))
        ))))

  (prag-listener 'amb knowledge)
  ;;   (KL (speakers-belief '(3 3) true) (listener 'amb true 3 6))
  ;;   (listener 'amb true 3 6)
  ;;     (speaker #t '(3 4) 3 6 knowledge)
  ;;   (speakers-belief '(3 4) true)
  ;;   (bstate-distribution)

  )

;; speaker rationality
(define alpha 1.375)

; (multiviz
;  (barplot (plural-predication 2 'no false) "no noise")
;  (barplot (plural-predication 2 'low false) "low noise")
;  (barplot (plural-predication 2 'mid false) "mid noise")
;  (barplot (plural-predication 2 'high false) "high noise")
;  )

;; wrapper

(define model
  (mem
     (lambda (number-of-objects 
          noise 
          knowledge
          )     
       (display (string-append "beginning model with noise=" noise))  
       (define likelihood (plural-predication 
                  number-of-objects 
                  noise 
                  knowledge
                  ))
       (list  noise 
            number-of-objects 
            knowledge
            likelihood))))


(define noises '(mid))
(define numbers-of-objects '(3))
(define knowledges '(true false))

(define (unpack m)
  (apply map (append (list (lambda (state-etc probability)
                             (append
                              (list (first m)
                                    (second m)
                                    (third m)
                                    (first state-etc))
                              (second state-etc)
                              (list probability))))
                 (last m))))

(define data
  (apply append
  (apply append
    (apply append       
      (map (lambda (knowledge)
      (map (lambda (noise)
        (map (lambda (number-of-objects)
               (define m (model number-of-objects noise knowledge))
               (unpack m))
         numbers-of-objects)) 
      noises))    
    knowledges))
    )
))

(display data)

(write-csv data "plural-predication-heavy.csv")