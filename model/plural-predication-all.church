;; helper function to check list identity
(define (naive-list-equals? as bs)
  (if (not (= (length as) (length bs)))
      false
      (all (map equal? as bs))))

;; helper function to get position of an element x in a haystack lst
(define (position* lst x) 
  (if (null? lst) 
      -Infinity
      (if (naive-list-equals? (first lst) x)
          0
          (+ 1 (position* (rest lst) x)))))

;; helper functiont to compute the maximum support for KL
(define max-support 
  (lambda (dist maximal-support)
    (map 
     (lambda (x)
       (if (> (position* (first dist) x) -1)
           (list-ref (second dist) (position* (first dist) x))
           0))
     (first maximal-support))))

;; helper function to compute KL divergence
(define (KL P Q)
  (sum (map (lambda (xp xq)
              (if (= xp 0)
                  0
                  (*
                   xp
                   (log (/ xp
                           xq)))))
            P Q)))

;; helper function for speaker optimality
(define (power lst alpha) (map (lambda (x) (expt x alpha)) lst))
(define (topower dist alpha) (list (first dist)
                                   (power (second dist) alpha)))

;; the full model starts here
(define (plural-predication number-of-objects
                            noise
                            knowledge
                            )

  ;; possible utterance 
  (define utterances (list  
                      'amb
                      'collective 
                      'distributive 
                      ))

  ;; ambiguous utterance is cheaper
  (define (utterance-prior) (multinomial utterances '(1 1 1)))

  ;; object come in two sizes, 3 and 4  , with equal probability
  (define object-prior '((3 4) (1 1)))

  ;; states are n random draws from the obejct prior where n=number-of-objects
  (define (state-prior) 
    (repeat number-of-objects (lambda () (apply multinomial object-prior) 
                                )))

  ;; prior on thresholds
  (define (dist-theta-prior) (apply multinomial object-prior))
  (define (coll-theta-prior) (sum (state-prior)))


  ;; contextual noise in collective interpretation
  (define noise-prior (case noise
                            (('no)
                             (lambda () 1)) ;; no noise                            
                            (('low)
                             (lambda () (multinomial '(.9 1 1.1) 
                                                     '(1 6 1)))) ;; low
                            (('mid) 
                             (lambda () (multinomial '(.7 1 1.3) 
                                                     '(1 3 1)))) ;; middle
                            (('high)
                             (lambda () (multinomial '(.5 1 1.5) 
                                                     '(1 1 1)))) ;; high
                            (('heavy-reg)
                             (lambda () (multinomial '(.925 1 1.075) 
                                                     '(1 6 1)))) ;; (heavy; regular)
                            (('heavy-ran)
                             (lambda () (multinomial '(.85 1 1.15) 
                                                     '(1 6 1)))) ;; (heavy; random)
                            (('tall-reg)
                             (lambda () 1)) ;; (tall; regular)                         
                            (('big-reg)
                             (lambda () (multinomial '(.924 1 1.076) 
                                                     '(1 9 1)))) ;; (big; regular)
                            (('tall-ran)
                             (lambda () (multinomial '(.85 1 1.15) 
                                                     '(1 8 1)))) ;; (tall; random)
                            (('big-ran)
                             (lambda () (multinomial '(.85 1 1.15) 
                                                     '(1 3 1)))) ;; (big; random)
                            ))

  ;; interpretation semantics
  (define collective-interpretation 
    (lambda (state coll-theta collective-noise) 
      (if
       (> (* collective-noise (sum state))  coll-theta) 
       #t
       #f)))
  (define distributive-interpretation 
    (lambda (state dist-theta) 
      (if
       (all (map (lambda (d) (> d dist-theta)) state))
       ; (flip 0.99)
       ; (flip 0.01))))
       #t
       #f)))

  ;; utterance semantics
  (define (meaning utterance state dist-theta coll-theta collective? collective-noise)
    (case utterance
          (('amb)
           (if collective?
               (collective-interpretation state coll-theta collective-noise)
               (distributive-interpretation state dist-theta)))
          (('not-amb)
           (if collective?
               (not (collective-interpretation state coll-theta collective-noise))
               (not (distributive-interpretation state dist-theta))))
          (('distributive)
           (distributive-interpretation state dist-theta))
          (('collective)
           (collective-interpretation state coll-theta collective-noise))))

  ;; pragmatic listener L1
  (define prag-listener
    (mem
     (lambda (utterance speakerknows)
       (enumeration-query
        (define state (state-prior))
        (define collective? (flip 0.88)) ; prior on collective interpretation
        (define dist-theta (dist-theta-prior))
        (define coll-theta (coll-theta-prior))

        (list collective? state)

        (condition (equal? utterance 
                           (apply multinomial 
                                  (topower (speaker collective? state dist-theta coll-theta speakerknows)
                                           2)))) ;; speaker optimality
        ))))

  ;; speaker belief function for epistemic manipulation
  (define speakers-belief
    (mem
     (lambda (state knowledge)
       (define (obs s) (if knowledge s (sum s)))
       (enumeration-query
        (define bstate (state-prior))
        bstate
        (equal? (obs bstate) (obs state))
        ))))

  ;; speaker S1
  (define speaker 
    (mem
     (lambda (collective? state dist-theta coll-theta knowstate)
       (enumeration-query
        (define utterance (utterance-prior))
        (define bstate-distribution (speakers-belief state knowstate))
        (define listener-dist (listener utterance collective? dist-theta coll-theta))
        (define speaker-dist 
          (max-support bstate-distribution listener-dist))


        utterance

        (factor (- (KL speaker-dist (second listener-dist))))
        ))))

  ;; literal listener L0
  (define listener
    (mem
     (lambda (utterance collective? dist-theta coll-theta)
       (enumeration-query
        (define collective-noise (noise-prior))
        (define state (state-prior))
        state
        (condition (meaning utterance state dist-theta coll-theta collective? collective-noise))
        ))))

  ;; model computes probability of collective for ambiguous utterance
  (prag-listener 'amb knowledge) 

  )

; ;; model predictions for 4-object states
; (barplot (plural-predication 4 'no #T) "no noise, full knowledge")
; (barplot (plural-predication 4 'no #F) "no noise, partial knowledge")
; (barplot (plural-predication 4 'low #T) "low noise, full knowledge")
; (barplot (plural-predication 4 'low #F) "low noise, partial knowledge")
; (barplot (plural-predication 4 'mid #T) "mid noise, full knowledge")
; (barplot (plural-predication 4 'mid #F) "mid noise, partial knowledge")
; (barplot (plural-predication 4 'high #T) "high noise, full knowledge")
; (barplot (plural-predication 4 'high #F) "high noise, partial knowledge")



;; speaker rationality
; (define alpha 2)

; (multiviz
;  (barplot (plural-predication 2 'no false) "no noise")
;  (barplot (plural-predication 2 'low false) "low noise")
;  (barplot (plural-predication 2 'mid false) "mid noise")
;  (barplot (plural-predication 2 'high false) "high noise")
;  )

;; wrapper

(define model
  (mem
     (lambda (number-of-objects 
          noise 
          knowledge
          )     
       (display (string-append "beginning model with noise=" noise))  
       (define likelihood (plural-predication 
                  number-of-objects 
                  noise 
                  knowledge
                  ))
       (list  noise 
            number-of-objects 
            knowledge
            likelihood))))


(define noises '(heavy-ran heavy-reg tall-ran tall-reg big-ran big-reg))
(define numbers-of-objects '(4))
(define knowledges '(true false))

(define (unpack m)
  (apply map (append (list (lambda (state-etc probability)
                             (append
                              (list (first m)
                                    (second m)
                                    (third m)
                                    (first state-etc))
                              (second state-etc)
                              (list probability))))
                 (last m))))

(define data
  (apply append
  (apply append
    (apply append       
      (map (lambda (knowledge)
      (map (lambda (noise)
        (map (lambda (number-of-objects)
               (define m (model number-of-objects noise knowledge))
               (unpack m))
         numbers-of-objects)) 
      noises))    
    knowledges))
    )
))

(display data)

(write-csv data "plural-predication-all.csv")