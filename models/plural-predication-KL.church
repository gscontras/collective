(define (KL P Q)
(sum (map (lambda (xp xq)
        (*
         xp
         (log (/ xp
                 xq))))
      (second P) (second Q))))

;; speaker rationality?
(define alpha 10)

;; Helper function
(define (power lst alpha) (map (lambda (x) (expt x alpha)) lst))

;; plural predication: 
;; take in the noise level and compute likelihood of collective interpretation for ambiguous utterance
(define plural-predication 
  (mem
   (lambda (noise)

     ;;  Utterances and their costs
     ;;  Utterances and their costs
     (define utterances (list 'null 'amb 'collective 'distributive))
     (define (utterance-prior) (multinomial utterances '(4 3 1 2))) ;; check actual frequencies?

     ;;   Prior on the number of objects
     (define (number-of-objects-prior) (uniform-draw '(2)))

     ;;   Prior on object size
     (define object-prior '(
                            (1 2) ; box mean size plus 1st and 3rd quartile
                            (1 1)))

     ;; Prior on state
     (define (state-prior) (uniform-draw '((1 1 1) (1 1 2) (1 2 1) (1 2 2) (2 1 1) (2 1 2) (2 2 1) (2 2 2))))

     ;; Prior on theta
     (define (dist-theta-prior) (apply multinomial object-prior))
     (define (coll-theta-prior) ; possible summation of four objects
       (multinomial
        '(3 4 5 6)
        '(0.125 0.375 0.375 0.125)
        ))

     ;;  collective measurement noise
     (define noise-prior (case noise
                               (('low)
                                (lambda () (multinomial '(.5 1 1.5) 
                                                        '(1 6 1)))) ;; low
                               (('mid) 
                                (lambda () (multinomial '(.5 1 1.5) 
                                                        '(1 3 1)))) ;; middle
                               (('high)
                                (lambda () (multinomial '(.5 1 1.5) 
                                                        '(1 1 1)))) ;; high
                               )) 

     ;; truth conditions
     (define collective-interpretation 
       (lambda (state coll-theta collective-noise) 
         (if
          (> (sum state) (* collective-noise coll-theta)) ; noise as multiplier
          (flip 0.95)
          (flip 0.05))))
     (define distributive-interpretation 
       (lambda (state dist-theta) 
        (if
         (all (map (lambda (d) (> d dist-theta)) state))
         (flip 0.95)
         (flip 0.05))))

     ;; meaning functions
     (define (meaning utterance state dist-theta coll-theta collective? collective-noise)
       (case utterance
             (('null)
              #t)
             (('amb)
              (if collective?
                  (collective-interpretation state coll-theta collective-noise)
                  (distributive-interpretation state dist-theta)))
             (('distributive)
              (distributive-interpretation state dist-theta))
             (('collecitve)
              (collective-interpretation state coll-theta collective-noise))))

     ;; Pragmatic listener
     (define prag-listener
       (mem
        (lambda (utterance)
          (enumeration-query
           (define number-of-objects (number-of-objects-prior))
           (define state (state-prior))
           (define collective? (case utterance 
                                     (('amb) (flip 0.2))))
           (define dist-theta (dist-theta-prior))
            (define coll-theta (coll-theta-prior)) ; coll-theta independent
;;            (define coll-theta dist-theta) ; coll-theta is the same as dist-theta
;;           (define coll-theta (* dist-theta number-of-objects))
;;              (list collective? dist-theta coll-theta)
           collective?

           (condition (equal? (apply multinomial (speaker collective? (sum state) dist-theta coll-theta)) utterance))
           ))))

     ;; Speaker
     (define (speaker collective? sum-state dist-theta coll-theta)
       (enumeration-query
        (define utterance (utterance-prior))
        (define listeners-world (apply multinomial 
                                       (list (first (listener utterance collective? dist-theta coll-theta
                                                              )) 
                                       (power (second (listener utterance collective? dist-theta coll-theta)) 
                                              alpha))))
         (define speakers-state
           (lambda (s-state)
                  (enumeration-query
                    (define state (state-prior))
                    state
                    (equal? (sum state) s-state)
                   )))

        utterance

        (flip (exp (* -1 (KL (listener utterance collective? dist-theta coll-theta) (speakers-state sum-state) ))))
        ))

     ;; Literal listener
     (define listener
       (mem
        (lambda (utterance collective? dist-theta coll-theta)
          (enumeration-query
           (define collective-noise (noise-prior))
           (define state (state-prior))
           state
           (condition (meaning utterance state dist-theta coll-theta collective? collective-noise))
           ))))

     (prag-listener 'amb)

     )))

;; wrapper for the plural predication model
(define model
  (mem
  (lambda (noise)
    (display (string-append "beginning model with noise=" noise))
     (define likelihood 
          (plural-predication noise))
     (list  noise 
          likelihood))))

;; possible values for noise
(define noises '(high mid low))

;; pair noise level with likelihood of collective interpretation for ambiguous utterance
(define data
  (map (lambda (noise)
    (model noise)) noises))

(display data)


;; RESULTS  ((high ((#f #t) (0.722194678386901 0.27780532161309884))) 
;;          (mid ((#f #t) (0.6935421702334652 0.3064578297665349))) 
;;          (low ((#f #t) (0.664270165533378 0.3357298344666219))))


